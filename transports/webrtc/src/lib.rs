// Copyright 2022 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//! Implementation of the [`Transport`] trait for WebRTC direct protocol. "direct" here means
//! communicating without a signaling server.
//!
//! # Overview
//!
//! ## ICE
//!
//! RFCs: 8839, 8445 See also:
//! https://tools.ietf.org/id/draft-ietf-rtcweb-sdp-08.html#rfc.section.5.2.3
//!
//! The WebRTC protocol uses ICE in order to establish a connection.
//!
//! In a typical ICE setup, there are two endpoints, called agents, that want to communicate. One
//! of these two agents is the local browser, while the other agent is the target of the
//! connection.
//!
//! Even though in this specific context all we want is a simple client-server communication, it is
//! helpful to keep in mind that ICE was designed to solve the problem of NAT traversal.
//!
//! The ICE workflow works as follows:
//!
//! - An "offerer" determines ways in which it could be accessible (either an
//!   IP address or through a relay using a TURN server), which are called "candidates". It then
//!   generates a small text payload in a format called SDP, that describes the request for a
//!   connection.
//! - The offerer sends this SDP-encoded message to the answerer. The medium through which this
//!   exchange is done is out of scope of the ICE protocol.
//! - The answerer then finds its own candidates, and generates an answer, again in the SDP format.
//!   This answer is sent back to the offerer.
//! - Each agent then tries to connect to the remote's candidates.
//!
//! We pretend to send the offer to the remote agent (the target of the connection), then pretend
//! that it has found a valid IP address for itself (i.e. a candidate), then pretend that the SDP
//! answer containing this candidate has been sent back. This will cause the offerer to execute
//! step 4: try to connect to the remote's candidate.
//!
//! ## 1 vs N data channels
//!
//! The SDP message generated by the offerer contains the list of so-called "media streams" that it
//! wants to open. In our specific use-case, we configure the transport to always request one data
//! stream.
//!
//! For this prototype, we have choosen to implement a single data channel and multiplex on top
//! because doing N channels will force us to rewrite a significant part of smoldot, which isn't
//! ready at all to have encryption and multiplexing handled "externally".
//!
//! ## TCP or UDP
//!
//! WebRTC by itself doesn't hardcode any specific protocol for these media streams. Instead, it is
//! the SDP message of the offerer that specifies which protocol to use. In our use case, one data
//! stream, we know that the offerer will always request either TCP+DTLS+SCTP, or UDP+DTLS+SCTP.
//!
//! ## DTLS+SCTP
//!
//! RFCs: 8841, 8832
//!
//! In both cases (TCP or UDP), the next layer is DTLS. DTLS is similar to the well-known TLS
//! protocol, except that it doesn't guarantee ordering of delivery (as this is instead provided by
//! the SCTP layer on top of DTLS). In other words, once the TCP or UDP connection is established,
//! the browser will try to perform a DTLS handshake.
//!
//! During the ICE negotiation, each agent must include in its SDP packet a hash of the self-signed
//! certificate that it will use during the DTLS handshake. In our use-case, where we try to
//! hand-crate the SDP answer generated by the remote, this is problematic. One way to solve this
//! is to make the hash a part of the remote's multiaddr.
//!
//! ## PeerId
//!
//! Ideally, we would just add a field in the certificate that contains a signature of the
//! certificate made using the PeerId. But you can't do that, as it's a chicken and egg problem:
//! you can't modify the certificate anymore after you've created a signature of it. We could find
//! some semi-hacky system where the signature is made against the certificate but with this field
//! removed, but that's very hacky as well.
//!
//! For now we'll start an encryption protocol handshake on top of the single data channel. Once
//! this handshake has been successful, we stop it and just use DTLS.

pub mod connection;
pub mod error;
pub mod transport;

mod sdp;
mod udp_mux;
mod upgrade;
