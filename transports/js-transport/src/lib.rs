// Copyright 2019 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//! Allows using a transport from js-libp2p with rust-libp2p

use futures::future::FutureResult;
use libp2p_core::{Multiaddr, Transport, transport::TransportError};
use send_wrapper::SendWrapper;
use std::{error, fmt};
use wasm_bindgen::{JsCast, prelude::*};

mod connection;
mod dial;
mod listen;

pub use connection::Connection;
pub use dial::DialFuture;
pub use listen::Listener;

/// Allows using as a `Transport` a JavaScript object that implements the `js-libp2p-transport`
/// interface.
pub struct JsTransport {
    /// The object that implements `js-libp2p-transport`.
    transport: SendWrapper<JsValue>,

    /// Function that be called with a string in order to build a JavaScript multiaddr, which can
    /// then be passed to the `transport`.
    multiaddr_constructor: SendWrapper<js_sys::Function>,
}

impl Clone for JsTransport {
    fn clone(&self) -> JsTransport {
        JsTransport {
            transport: SendWrapper::new(self.transport.clone()),
            multiaddr_constructor: SendWrapper::new(self.multiaddr_constructor.clone()),
        }
    }
}

impl JsTransport {
    /// Creates an implementation of `Transport` that uses the given JavaScript transport inside.
    ///
    /// Must be passed an object that implements the `js-libp2p-transport` interface (see
    /// https://github.com/libp2p/interface-transport), and a function that, when passed a string,
    /// returns a JavaScript multiaddr object.
    pub fn new(transport: JsValue, multiaddr_constructor: JsValue) -> Result<JsTransport, JsErr> {
        let multiaddr_constructor = multiaddr_constructor
            .dyn_into::<js_sys::Function>()
            .map_err(|v| {
                let msg = format!("Expected multiaddr_constructor to be a function, got {:?}", v);
                JsErr::from(JsValue::from_str(&msg))
            })?;

        Ok(JsTransport {
            transport: SendWrapper::new(transport),
            multiaddr_constructor: SendWrapper::new(multiaddr_constructor),
        })
    }

    /// Translates from a Rust `multiaddr` into a JavaScript `multiaddr`.
    fn build_js_multiaddr(&self, addr: Multiaddr) -> Result<JsValue, JsErr> {
        Ok(self.multiaddr_constructor
            .call1(&self.multiaddr_constructor, &JsValue::from_str(&addr.to_string()))?)
    }
}

impl fmt::Debug for JsTransport {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt.debug_tuple("JsTransport").finish()
    }
}

impl Transport for JsTransport {
    type Output = Connection;
    type Error = JsErr;
    type Listener = Listener;
    type ListenerUpgrade = FutureResult<Self::Output, Self::Error>;
    type Dial = DialFuture;

    fn listen_on(self, addr: Multiaddr) -> Result<(Self::Listener, Multiaddr), TransportError<Self::Error>> {
        let js_multiaddr = self.build_js_multiaddr(addr).map_err(TransportError::Other)?;
        listen::listen_on(&self.transport, js_multiaddr).map_err(TransportError::Other)
    }

    fn dial(self, addr: Multiaddr) -> Result<Self::Dial, TransportError<Self::Error>> {
        let js_multiaddr = self.build_js_multiaddr(addr).map_err(TransportError::Other)?;
        dial::dial(&self.transport, js_multiaddr).map_err(TransportError::Other)
    }

    fn nat_traversal(&self, _server: &Multiaddr, _observed: &Multiaddr) -> Option<Multiaddr> {
        // TODO: ?
        None
    }
}

/// Error that can be generated by the `JsTransport`.
pub struct JsErr(SendWrapper<JsValue>);

impl From<JsValue> for JsErr {
    fn from(val: JsValue) -> JsErr {
        JsErr(SendWrapper::new(val))
    }
}

impl fmt::Debug for JsErr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", &*self.0)
    }
}

impl fmt::Display for JsErr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", &*self.0)
    }
}

impl error::Error for JsErr {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        None
    }
}
